{"version":3,"file":"resolver.js","sourceRoot":"","sources":["../src/resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import { Wretcher } from \"./wretcher\"\nimport { mix } from \"./mix\"\nimport conf from \"./config\"\nimport perfs from \"./perfs\"\nimport { middlewareHelper } from \"./middleware\"\n\nexport type WretcherError = Error & { status: number, response: WretcherResponse, text?: string, json?: any }\nexport type WretcherErrorCallback = (error: WretcherError, originalRequest: Wretcher) => any\nexport type WretcherResponse = Response & { [key: string]: any }\nexport type ResponseChain = {\n    // Response types\n    res: <Result = WretcherResponse>(cb?: (type: WretcherResponse) => Result) => Promise<Result>,\n    json: <Result = {[key: string]: any}>(cb?: (type: {[key: string]: any}) => Result) => Promise<Result>,\n    blob: <Result = Blob>(cb?: (type: Blob) => Result) => Promise<Result>,\n    formData: <Result = FormData>(cb?: (type: FormData) => Result) => Promise<Result>,\n    arrayBuffer: <Result = ArrayBuffer>(cb?: (type: ArrayBuffer) => Result) => Promise<Result>,\n    text: <Result = string>(cb?: (type: string) => Result) => Promise<Result>,\n    // Extras\n    perfs: (cb?: (timing: any) => void) => ResponseChain,\n    setTimeout: (time: number, controller?: AbortController) => ResponseChain,\n    controller: () => [any, ResponseChain],\n    // Catchers\n    error: (code: (number | string), cb: WretcherErrorCallback) => ResponseChain,\n    badRequest: (cb: WretcherErrorCallback) => ResponseChain,\n    unauthorized: (cb: WretcherErrorCallback) => ResponseChain,\n    forbidden: (cb: WretcherErrorCallback) => ResponseChain,\n    notFound: (cb: WretcherErrorCallback) => ResponseChain,\n    timeout: (cb: WretcherErrorCallback) => ResponseChain,\n    internalError: (cb: WretcherErrorCallback) => ResponseChain,\n    fetchError: (cb: WretcherErrorCallback) => ResponseChain,\n    onAbort: (cb: WretcherErrorCallback) => ResponseChain\n}\n\nclass WretchErrorWrapper {\n    constructor(public error: any) {}\n}\n\nexport const resolver = (wretcher: Wretcher) => {\n    const {\n        _url: url,\n        _catchers: _catchers,\n        _resolvers: resolvers,\n        _middlewares: middlewares,\n        _options: opts\n    } = wretcher\n    const catchers = new Map(_catchers)\n    const finalOptions = mix(conf.defaults, opts)\n    const fetchController = conf.polyfill(\"AbortController\", { doThrow: false, instance: true })\n    if(!finalOptions[\"signal\"] && fetchController) {\n        finalOptions[\"signal\"] = fetchController.signal\n    }\n    // Request timeout\n    const timeout = {\n        ref: null,\n        clear() {\n            if(timeout.ref) {\n                clearTimeout(timeout.ref)\n                timeout.ref = null\n            }\n        }\n    }\n    // The generated fetch request\n    const fetchRequest = middlewareHelper(middlewares)(conf.polyfill(\"fetch\"))(url, finalOptions)\n    // Throws on an http error\n    const throwingPromise: Promise<void | WretcherResponse> = fetchRequest\n        .catch(error => {\n            throw new WretchErrorWrapper(error)\n        })\n        .then(response => {\n            timeout.clear()\n            if (!response.ok) {\n                return response[conf.errorType || \"text\"]().then(msg => {\n                    // Enhances the error object\n                    const err = new Error(msg)\n                    err[conf.errorType || \"text\"] = msg\n                    err[\"status\"] = response.status\n                    err[\"response\"] = response\n                    throw err\n                })\n            }\n            return response\n        })\n    // Wraps the Promise in order to dispatch the error to a matching catcher\n    const catchersWrapper = <T>(promise: Promise<T>): Promise<void | T> => {\n        return promise.catch(err => {\n            timeout.clear()\n            const error = err instanceof WretchErrorWrapper ? err.error : err\n            if(err instanceof WretchErrorWrapper && catchers.has(\"__fromFetch\"))\n                return catchers.get(\"__fromFetch\")(error, wretcher)\n            else if(catchers.has(error.status))\n                return catchers.get(error.status)(error, wretcher)\n            else if(catchers.has(error.name))\n                return catchers.get(error.name)(error, wretcher)\n            else\n                throw error\n        })\n    }\n    // Enforces the proper promise type when a body parsing method is called.\n    type BodyParser = <Type>(funName: string | null) => <Result = void>(cb?: (type: Type) => Result) => Promise<Result>\n    const bodyParser: BodyParser = <T>(funName) => <R>(cb) => funName ?\n        // If a callback is provided, then callback with the body result otherwise return the parsed body itself.\n        catchersWrapper(throwingPromise.then(_ => _ && _[funName]()).then(_ => cb ? cb(_) : _)) :\n        // No body parsing method - return the response\n        catchersWrapper(throwingPromise.then(_ => cb ? cb(_) : _))\n\n    const responseChain: ResponseChain = {\n        /**\n         * Retrieves the raw result as a promise.\n         */\n        res: bodyParser<WretcherResponse>(null),\n        /**\n         * Retrieves the result as a parsed JSON object.\n         */\n        json: bodyParser<any>(\"json\"),\n        /**\n         * Retrieves the result as a Blob object.\n         */\n        blob: bodyParser<Blob>(\"blob\"),\n        /**\n         * Retrieves the result as a FormData object.\n         */\n        formData: bodyParser<FormData>(\"formData\"),\n        /**\n         * Retrieves the result as an ArrayBuffer object.\n         */\n        arrayBuffer: bodyParser<ArrayBuffer>(\"arrayBuffer\"),\n        /**\n         * Retrieves the result as a string.\n         */\n        text: bodyParser<string>(\"text\"),\n        /**\n         * Performs a callback on the API performance timings of the request.\n         *\n         * Warning: Still experimental on browsers and node.js\n         */\n        perfs: cb => {\n            fetchRequest.then(res => perfs.observe(res.url, cb))\n            return responseChain\n        },\n        /**\n         * Aborts the request after a fixed time.\n         *\n         * @param time Time in milliseconds\n         * @param controller A custom controller\n         */\n        setTimeout: (time, controller = fetchController) => {\n            timeout.clear()\n            timeout.ref = setTimeout(() => controller.abort(), time)\n            return responseChain\n        },\n        /**\n         * Returns the automatically generated AbortController alongside the current wretch response as a pair.\n         */\n        controller: () => [ fetchController, responseChain ],\n        /**\n         * Catches an http response with a specific error code or name and performs a callback.\n         */\n        error(errorId, cb) {\n            catchers.set(errorId, cb)\n            return responseChain\n        },\n        /**\n         * Catches a bad request (http code 400) and performs a callback.\n         */\n        badRequest: cb => responseChain.error(400, cb),\n        /**\n         * Catches an unauthorized request (http code 401) and performs a callback.\n         */\n        unauthorized: cb => responseChain.error(401, cb),\n        /**\n         * Catches a forbidden request (http code 403) and performs a callback.\n         */\n        forbidden: cb => responseChain.error(403, cb),\n        /**\n         * Catches a \"not found\" request (http code 404) and performs a callback.\n         */\n        notFound: cb => responseChain.error(404, cb),\n        /**\n         * Catches a timeout (http code 408) and performs a callback.\n         */\n        timeout: cb => responseChain.error(408, cb),\n        /**\n         * Catches an internal server error (http code 500) and performs a callback.\n         */\n        internalError: cb => responseChain.error(500, cb),\n        /**\n         * Catches errors thrown when calling the fetch function and performs a callback.\n         */\n        fetchError: cb => responseChain.error(\"__fromFetch\", cb),\n        /**\n         * Catches an AbortError and performs a callback.\n         */\n        onAbort: cb => responseChain.error(\"AbortError\", cb)\n    }\n\n    return resolvers.reduce((chain, r) => r(chain, wretcher), responseChain) as (ResponseChain & Promise<any>)\n}\n"]}